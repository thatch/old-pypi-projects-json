{
    "info": {
        "author": "Wellington Rats",
        "author_email": "wellrats@gmail.com",
        "bugtrack_url": null,
        "classifiers": [
            "Development Status :: 5 - Production/Stable",
            "Intended Audience :: Developers",
            "License :: Freely Distributable",
            "License :: OSI Approved :: BSD License",
            "Operating System :: OS Independent",
            "Programming Language :: Python",
            "Programming Language :: Python :: 2",
            "Programming Language :: Python :: 2.3",
            "Programming Language :: Python :: 2.4",
            "Programming Language :: Python :: 2.5",
            "Programming Language :: Python :: 2.6",
            "Programming Language :: Python :: 2.7",
            "Programming Language :: Python :: 3",
            "Programming Language :: Python :: 3.5",
            "Programming Language :: Python :: 3.6",
            "Programming Language :: Python :: 3.7",
            "Programming Language :: Python :: 3.8",
            "Programming Language :: Python :: Implementation",
            "Programming Language :: Python :: Implementation :: CPython",
            "Topic :: Software Development",
            "Topic :: Software Development :: Build Tools",
            "Topic :: Software Development :: Code Generators",
            "Topic :: Software Development :: Compilers",
            "Topic :: Software Development :: Libraries :: Python Modules"
        ],
        "description": "\nWelcome to GitHub repository of Pypp \n====================================\n\n**Pypp** is the implementation of a c-stype preprocessor for Python Programming Languages 2.7+\n\nA preprocessor is a program that takes a input Source Code written using some\nprogramming language syntax and outputs an output Source Code that translate,\nexpand or modify original programming language.\n\nFor example, from this:\n\n.. code:: python\n\n    from pypp import py_preprocessor\n    PYPP = py_preprocessor()\n    PYPP.parse(__file__, __name__)\n\n    \"\"\"This source will work in both Python versions\"\"\"\n\n    def main():\n\n       #ifdef __PYTHON2__\n       #expand print \"This will work in\", \"Python 2\", \"like a charm\"\n       #else\n       print(\"This will work in Python 3 like a charm\")\n       #endif\n\n    if __name__ == \"__main__\": main()\n\nto this if we are using Python 3+\n\n.. code:: python\n\n    \"\"\"This source will work in both Python versions\"\"\"\n\n    def main():\n\n       print(\"This will work in Python 3 like a charm\")\n\n    if __name__ == \"__main__\": main()\n\nTable of Contents\n=================\n\n.. contents::\n\nIntroduction\n============\n\nI love to write code, and I love to keep my code clean and organized, specially when\nI publish it on github for example. I love to use the latest features of a\nlanguage and I specially love debug with ``print`` and a lot of dashes  ``'-'`` and so on.\n\nBut, when you write open source code, a lot of ``prints``, ``dashes`` and latest features\nare not welcome. Your code has to install and run in as many Python versions and platforms it it cans, and \nbe kept up to date, stable and without bugs. Python 2.7 support is dropped since January 2020, \nbut far away from be replaced. There is a lot of stuff that keeps working on it and still \nwill be for a long time.  Why? Because the cost of conversion is expensive, needs\ntime and effort. And all this code has to be mantained, keep evolving and will need packages \nupdates that be compatible with then and, when they began their conversion process, it will not be at once.\n\nSo this was the motivation to get the best of both worlds (thank you for Hanna Montanna). \nCreate a preprocessor for Python language that could keep final code clean, stable, runnable in \nany version of Python, working at run time, or used as a command line tool for batch conversion.\n\nInstalling\n----------\n\n**Pypp** can be easily installed via common Python package managers such as pip.\n\n::\n\n    $ pip install pypp\n\nYou may also get the latest **Pypp** version by grabbing the source code from Github:\n\n::\n\n    $ git clone https://github.com/wellrats/pypp\n    $ cd pypp\n    $ python setup.py install\n\nTo test your installation, Pypp come with a set of simple tutorials that can be executed once you \nhave deployed the packages\n\n::\n\n    python -m pypp.tests.test_helloworld\n\nor\n\n::\n\n    python3 -m pypp.tests.test_helloworld\n\nExamples\n--------\n\nPypp comes with some examples to check it out go to Pypp install directory\n\n::\n\n    $ cd $(dirname $(python -c \"import pypp; print(pypp.__file__)\"))\n    $ python tests/py2andpy3.py\n    $ python -m pypp py2andpy3.py -o -\n    $ python -m pypp py2andpy3.py -r -o -\n\nRuntime or command line processor?\n==================================\n\nUsually a preprocessor do its job at compile time, but Python don't have this feature \nso, pypy has two options do its job: at run time, when you are executing a source file as\na script or as a import module, or using a command line tool. Which to choose is up to you\nand your motivations to use a preprocessor. Let's see the diferences between then.\n\nRuntime preprocessor\n--------------------\n\nRunTime preprocessor is when you have the source code and wants to execute this code respecting the \npreprocessor directives. Probably you are a developer and want to insert some tests or let the code be prepared\nto future releases of Python, but don't want this ``test code`` in your final code on GitHub or in you client, or\nwants be able to generate many diferent codes from this one. \nThis source code can be executed as a script calling ``python yourscript.py`` or loaded as a module using import \n``import your_module``. Like was written before, Python does not implements a preprocessor feature at compile time, so Pypp will simulate it at run time.  \n\nBut how can we do it at runtime? How can we modify a code that is compiled and running? The answer is\nobvious: We can't. We can rewrite the code and executs it again, inside itself. In other words, we will execute\nthe source code twice. The first version is the original version where directives are seen as comments\nby compiler. This code will be compiled and executed normally. During this execution when the \n``PYPP.parse( ...`` code is executed,  the trick happens. All code is read again, preprocessed \nand directives do their job and a brand new code is created. This new code is executed and takes place \nof original code.  \n\nThere's a little difference if original code is executed as a script or is being imported. \nWhen the variable ``__name__`` has the value ``\"__main__\"``, Pypp assumes this is a script and not an\nimport module. The differences are bellow:\n\nHow Python and Pypp works when source code is a script\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst let's see a graphical flow how Python and Pypp will do their job to guarantee that the preprocessor will work\nproperly when running a script.\n\n::\n\n    Flow\n    |\n    1\ufe0f\u20e3 Python reads original .py script file\n    2\ufe0f\u20e3 compiles it in memory (.pyc)\n    3\ufe0f\u20e3 runs the compiled code\n       |\n       1\ufe0f\u20e3 All code before \"PYPP.parse( ...\" is executed \u2705\u2705\n       2\ufe0f\u20e3 When \"PYPP.parse( ...\" is called\n       |  |\n       |  1\ufe0f\u20e3 PYPP reads original .py file\n       |  2\ufe0f\u20e3 parse directives, clean the code and saves new code in memory\n       |  3\ufe0f\u20e3 call exec( ... ) to execute all new code\n       |  4\ufe0f\u20e3 call sys.exit(0) to stop old code execution\n       |    \n       3\ufe0f\u20e3 All code after \"PYPP.parse( ...\" from original compiled code is DISCARDED \u274c\u274c\n\nBe atention to step 3.2.4. When the code is executed as a script we can stop the execution of the old code, \nbecause we have sure that the new code was all executed stand alone. But we still have a problem. All the code \nbefore ``PYPP.parse( ...`` was executed twice. Right ? Yes and No. We have tools to prevent its to happen. \nLet's see an pratical example to understand better.\n\nSo the first step is instantiate a preprocessor in our source code:\n\n.. code:: python\n\n    from pypp import py_preprocessor\n    PYPP = py_preprocessor()\n\n\u2757\ufe0f **YOU CAN NOT** change this piece of code neither change ``PYPP.`` variable.\n\nThe reason is: When the preprocessor is doing its job, it will look for this piece of code\nand some references to ``PYPP`` variable so, it can be removed from final code.\n\nThe second step is write the directives in source code to give work to the preprocessor. \nDirectives are like coments and can be written anywhere in the code. All the directives and\nits rules will be explained bellow.\n\n.. code:: python\n\n    #ifdef debug\n    print(\"I'm a debug line running in Python __VERSION__ and won't be present in final code')\n    #endif\n\nThe third step is call the preprocessor so it can do its job:\n\n.. code:: python\n\n    PYPP.parse(__file__, __name__)\n\n\u2757\ufe0f **DON'T CHANGE** this line either.\n\nand finally we have our ``test_script01.py`` with other little stuff as :\n\n.. code:: python\n\n    import sys\n    from pypp import py_preprocessor\n    PYPP = py_preprocessor()\n\n    #exclude\n    if len(sys.argv) > 1 and sys.argv[1] == '-d': PYPP.define(\"debug\")\n    #endexclude\n\n    print(\"PRINT me always but just once. I'm using Python __VERSION__ !!!\")\n    PYPP.parse(__file__, __name__)\n\n    #ifdef debug\n    print(\"PRINT me only if '-d' used. I'm using Python __VERSION__ !!!\")\n    #endif\n\nSo, let's run it using python 3.7\n\n::\n\n    $ python3 -m pypp.tests.test_script01\n    PRINT me always but just once. I'm using Python __VERSION__ !!!\n    PRINT me always but just once. I'm using Python 3.7.6 !!!\n\n::\n\n    $ python3 -m pypp.tests.test_script01 -d\n    PRINT me always but just once. I'm using Python __VERSION__ !!!\n    PRINT me always but just once. I'm using Python 3.7.6 !!!\n    PRINT me only if '-d' used. I'm using Python 3.7.6 !!!\n\nWell, it didn't work as expected  \ud83d\ude29. The first print was executed twice. The reason was \nexplained earlier. All code before ``PYPP.parse( ...`` is executed at original code and at \npreprocessed code. To solve this we have many options. First let's understand that this happens\nonly to code that starts at column 1 (usually), with exception to classes and functions declarations. \nAll code inside classes and funcions are executed only when called, but all the rest is executed \ninstantly.\n\nThe options to solve this issue are:\n\n#. Move ``PYPP.parse( ...`` next to top of code so, there is no relevant code before it, but only the  \n   necessary to its own execution.\n\n#. Use the special logical condition ``if PYPP.parsed():`` to all relevant code before ``PYPP.parse( ...``. This\n   will prevent this code to be executed because this condition returns always ``False``, so nothing inside will\n   be executed with original code. The preprocessor recognizes this special logical condition, removes it \n   completely from final code and reident the code to it's original position.\n\nWith option 1 we have ``test_script02.py``:\n\n.. code:: python\n\n    import sys\n    from pypp import py_preprocessor\n\n    #exclude\n    if len(sys.argv) > 1 and sys.argv[1] == '-d': PYPP.define(\"debug\")\n    #endexclude\n\n    PYPP.parse(__file__, __name__)\n\n    print(\"PRINT me always but just once. I'm using Python __VERSION__ !!!\")\n\n    #ifdef debug\n    print(\"PRINT me only if '-d' used. I'm using Python __VERSION__ !!!\")\n    #endif\n\nWith option 2 we have ``test_script03.py``:\n\n.. code:: python\n\n    import sys\n    from pypp import py_preprocessor\n    PYPP = py_preprocessor()\n\n    # This is just a comment\n\n    #exclude\n    if len(sys.argv) > 1 and sys.argv[1] == '-d': PYPP.define(\"debug\")\n    #endexclude\n\n    if PYPP.parsed():\n       print(\"PRINT me always but just once. I'm using Python __VERSION__ !!!\")\n\n       #ifdef debug\n       print(\"PRINT me only if '-d' used. I'm using Python __VERSION__ !!!\")\n       #endif\n\n    PYPP.parse(__file__, __name__)\n\nSo, let's try again ...\n\n::\n\n    $ python3 -m pypp.tests.test_script02\n    PRINT me always but just once. I'm using Python 3.7.6 !!!\n\n::\n\n    $ python3 -m pypp.tests.test_script03 -d\n    PRINT me always but just once. I'm using Python 3.7.6 !!!\n    PRINT me only if '-d' used. I'm using Python 3.7.6 !!!\n\nYeah \ud83d\ude01. So the first rule of Pypp is that for scripts, we have to keep our ``PYPP.parse( ...`` call as next from top \nof code we can, or use ``if PYPP.parsed():`` logical condition, or both, so our code can be processed the way we\nwants. Another very important rule is:\n\n\u2757\ufe0f Your original source code **HAS TO BE** compilable in all Python versions, because this original source code has to\nrun so the processor can do its job.\n\nThis means that a code like:\n\n.. code:: python\n\n    #ifdef __PYTHON2__\n    print \"This is\", \"a debug code \", \"and will NOT run  in Python 3\"\n    #else\n    print(\"This is a debug code and is executes if we are using Python 3\")\n    #endif\n\nwill not compile in Python 3 because  second line will generate a syntax error. In these case if you can't change the original code you can use the directive ``#expand`` as you see bellow.\n\n.. code:: python\n\n    #ifdef __PYTHON2__\n    #expand print \"This is\", \"a debug code \", \"and will NOT run  in Python 3\"\n    #else\n    print(\"This is a debug code and is executes if we are using Python 3\")\n    #endif\n\nHow Python and Pypp works when source code is a module to be imported\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nNow, let's see a graphical flow how Python and Pypp will do their job to guarantee that the preprocessor will work\nproperly when importing a module\n\n::\n\n    Flow\n    |\n    1\ufe0f\u20e3 Another Python scripts or module imports our original .py  file\n    2\ufe0f\u20e3 Python reads original .py module file\n    3\ufe0f\u20e3 compiles it in memory (.pyc)\n    4\ufe0f\u20e3 loads, runs the compiled code and inserts an entry for it in ``sys.modules``\n       |\n       1\ufe0f\u20e3 All code before \"PYPP.parse( ...\" is executed \u2705\u2705\n       2\ufe0f\u20e3 When \"PYPP.parse( ...\" is called\n       |  |\n       |  1\ufe0f\u20e3 PYPP reads original .py file\n       |  2\ufe0f\u20e3 parse directives, clean the code and save new code in a file\n       |  3\ufe0f\u20e3 call __import__( ... ) to load the new code in the same ``sys.modules`` entry\n       |  4\ufe0f\u20e3 new code is executed\n       |    \n       3\ufe0f\u20e3 All code after \"PYPP.parse( ...\" from original compiled code IS EXECUTED TOO \u2705\u2705\n\nThere are diferences from a script code. We have ``sys.modules`` that has to be modified at runtime, we can't call\n``sys.exit`` because Python will halt and the most important, when the source file is \na module to be imported **all the original code will be executed** no matter which place you write \n``PYPP.parse( ...``. So we **HAVE** to use ``if PYPP.parsed():`` logical condition to prevent our code to be executed twice and avoid unpredictable runtime errors write ``PYPP.parse(...`` after all references to ``PYPP.`` in source code. Let's see some pratical examples to understand better. \n\nYou can protect only what is relevant. See ``import4.py``\n\n.. code:: python\n\n    import os\n    from pypp import py_preprocessor\n    PYPP = py_preprocessor()\n\n    class test_class(): # classes and functions are not a problem because are only compiled\n\n          def __init__(self):\n              print(\"This print has no problem\")\n\n    GLOBAL_VARIABLE = \"PYTHON vr __VERSION__\" \n    # global variable definitions are most of time safe to become unprotected\n\n    if PYPP.parsed(): # but code like this has to be protected at all\n\n       if os.path.isfile(\"/tmp/test.txt\"):\n          os.remove(\"/tmp/test.txt\")\n\n       print(\"module import4 imported and I was printed just once\")\n\n    PYPP.parse(__file__, __name__)\n\nOr you can protect the all code. See ``import5.py``\n\n.. code:: python\n\n    import os\n    from pypp import py_preprocessor\n    PYPP = py_preprocessor()\n\n    if PYPP.parsed(): # You can protect the all code\n\n       class test_class(): # classes and functions are not a problem because are only compiled\n\n             def __init__(self):\n                 print(\"This print has no problem\")\n\n       GLOBAL_VARIABLE = \"PYTHON vr __VERSION__\" \n       # global variable definitions are most of time safe to become unprotected\n\n       if os.path.isfile(\"/tmp/test.txt\"):\n          os.remove(\"/tmp/test.txt\")\n\n       print(\"module import5 imported and I was printed just once\")\n\n    PYPP.parse(__file__, __name__)\n\nOr you can protect nothing if you code has only global, classes and defs definitions. See ``test06_import_module.py``\n\n.. code:: python\n\n    from pypp import py_preprocessor\n    PYPP = py_preprocessor()\n\n    GLOBAL_VARIABLE = \"PYTHON vr __VERSION__\" \n    # global variable definitions are most of time safe to become unprotected\n    class test_class(): # classes and functions are not a problem because are only compiled\n\n          def __init__(self):\n              print(\"This print has no problem\")\n\n    print(\"I don't care if this line is printed twice\")\n\n    PYPP.parse(__file__, __name__)\n\nLet's import all of then\n\n>>> pypp.tests.imports import impor4\nmodule import4 was imported and I was printed just once\n>>> pypp.tests.imports import impor5\nmodule import5 was imported and I was printed just once\n>>> pypp.tests.imports import impor6\nI don't care if this line is printed twice\nI don't care if this line is printed twice\n\nYeah again\ud83d\ude01. Here the rule is that for import modules, we have to use ``if PYPP.parsed():`` logical condition, in the whole code if necessary, and write ``PYPP.parse (...`` at the end of our source code, so our code can be processed the way we wants. \n\nAnother thing that is very important:\n\n| \u2757\ufe0f ``if PYPP.parsed():`` logical condition, **CAN ALSO** be replaced by ``if False and False:``. \n| \u2757\ufe0f Pypp will understand this too.\n\nCommand line preprocessor\n-------------------------\n\nCommand line preprocessor is when you have source code files and wants to generate new preprocessed files in\nbatch mode. Probably you are a developer and want to insert copyright marks, or remove something from final code, like\n``prints``, debugs and so on, or you know exactly what version of Python will execute your code and wants to\ngenerate a final code totally compatible with it. Almost like C does with ``make``.\n\nHere we have no flow. It's just a command line tool that has some parameters and you can run it from shell.\n\n::\n\n    $ python2.7+ -m pypp -r -d debug pypp/tests/test_commandline01.pyp \n\n\u2757\ufe0f The code generated is **DIRECTLY DEPENDENT** from the Python version you run the command line\n\nOptions\n^^^^^^^\n\nUsage: ``pypp [options] filename-or-directory [...]``\n\n-h, --help        show this help message and exit\n-v, --version     print Pypp version\n-d name           same as #define. Ex. ``-d`` debug or ``-d \"var=2+2\"`` (eval 4)\n-e EXT            include files with only these extensions. default is ``'.py'``\n                  and extensions must be separated with ``'|'`` char. Ex.\n                  ``'.py|.pypp'``\n-l MAXLEVELS      levels to recurse into subdirectories. Use ``'0'`` to don't\n                  recurse. Default is no limit\n-p PATH           directory to prepend to file names and paths before save\n                  processed files. The full path will be created if it does\n                  not exists\n-f                force overwrite of files when output file name has the\n                  same name of input file name\n-r                remove meta tags and commented lines from final code\n-o FILE           output file name when you are preprocessing just one file\n                  at once. Use ``'-o -'`` to stdout\n-q                output only error messages; ``-qq`` will suppress the error\n                  messages as well\n-c, --compileall  compile each file after preprocessing. When this option is\n                  used, no preprocessed source file will be saved to disk and\n                  options ``'-o'``, ``'-r'`` and ``'-f'`` are discarded\n-b                use legacy (pre-PEP3147) compiled file locations. Valid\n                  only when ``'-c'`` is used\n\nExamples\n^^^^^^^^\n\nLet's use one of our script files ``test_script03.py``\n\n.. code:: python\n\n    import sys\n    from pypp import py_preprocessor\n    PYPP = py_preprocessor()\n\n    # This is just a comment\n\n    #exclude\n    if len(sys.argv) > 1 and sys.argv[1] == '-d': PYPP.define(\"debug\")\n    #endexclude\n\n    if PYPP.parsed():\n       print(\"PRINT me always but just once. I'm using Python __VERSION__ !!!\")\n\n       #ifdef debug\n       print(\"PRINT me only if '-d' used. I'm using Python __VERSION__ !!!\")\n       #endif\n\n    PYPP.parse(__file__, __name__)\n\nNow let's run ``pypp`` and don't remove metada to see all preprocessor work.\n\n::\n\n    $ python3 -m pypp pypp/tests/test_script03.py -o -  \n\n.. code:: python\n\n    import sys\n    # from pypp import py_preprocessor\n    # PYPP = py_preprocessor()\n\n    # This is just a comment\n\n    # #exclude\n    # if len(sys.argv) > 1 and sys.argv[1] == '-d': PYPP.define(\"debug\")\n    # #endexclude\n\n    # if PYPP.parsed():\n    print(\"PRINT me always but just once. I'm using Python 3.7.6 !!!\")\n\n    # #ifdef debug\n    # print(\"PRINT me only if '-d' used. I'm using Python __VERSION__ !!!\")\n    # #endif\n\nRealize that any references to ``py_preprocessor`` were commented and the block ``if PYPP.parsed():`` \nhas been commented too and all code bellow was reidented.\nLet's remove metada data now.\n\n::\n\n    $ python3 -m pypp -r pypp/tests/test_script03.py -o -  \n\n.. code:: python\n\n    import sys\n\n    # This is just a comment\n\n    print(\"PRINT me always but just once. I'm using Python 3.7.6 !!!\")\n\n\n\u2757\ufe0f As you can see there is **NO DEPENDENCY** in final code from Pypp.\n\nPreprocessing and compiling code at once\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPypp can compile bytecode files (.pyc) directly from the preprocessed file without need to save the new file to\ndisk an execute ``python -m compileall``, and is as simple as this. Just use ``-c`` or ``--compileall`` option.\n\n::\n\n    $ python -m pypp --compileall diretory_or_file      # generate __pycache__/.pyc files\n    $ python -m pypp -b --compileall diretory_or_file   # generate .pyc files at same dir\n\nYour bytecodes (.pyc) where generated using the preprocessed file and are ready to deploy. For more \ninformation and usage execute ``python pypp --help``.\n\nExpander\n========\n\nPypp implements some expanders that look for names and special characters in the source code and replace then\nfor defined values or expressions.\n\nName definitions expander\n-------------------------\n\nAny references to name definitions done with ``#define`` in source file will be replaced by its ``repr()`` value.\nNote than any references means any place where definition names appears, even inside strings. To avoid this\nreplacement precede the name with ``'!'``\nFor example, the code:\n\n.. code:: Python\n\n    #define SIZE 100 * 2\n    #define TEXT \"Pypp\" + \" is \" + \"the best\"\n\n    for i in range(0, SIZE): print(TEXT)\n    print(\"The value of !TEXT is TEXT\")\n\nafter preprocessing will become:\n\n.. code:: Python\n\n    for i in range(0, 200): print('Pypp is the best')\n    print(\"The value of TEXT is 'Pypp is the best'\")\n\nExpressions expander\n--------------------\n\nFor more complexes replacements there is expression expander. All text between expander begin mark ``'#{'`` and\nexpander end mark ``}#'`` will be evaluated and replaced exactly at same place by its ``str()`` value. If you wants\nthat replacement value be by its ``repr()`` value, insert a modifier at end of expression, without spaces from ``'}'``.\nThe modifiers are ``',s`` for ``str()`` value and ``',r'`` for ``repr()`` value.\nFor example, the code:\n\n.. code:: Python\n\n    #! env python#{__VERSION__[0]}#\n\n    #define VALUE 5 if __PYTHON2__ else 6\n    #define TEXT \"Pypp\" + \" is \" + \"the best\"\n\n    print(\"!VALUE + 1 = #{VALUE + 1}# and #{TEXT}# and #{TEXT,r}#\")\n\nafter preprocessing with ``python2`` will become:\n\n.. code:: Python\n\n    #! env python2\n\n    print(\"VALUE + 1 = 6 and Pypp is the best and 'Pypp is the best'\")\n\nand after preprocessing with ``python3`` will become:\n\n.. code:: Python\n\n    #! env python3\n\n    print(\"VALUE + 1 = 7 and Pypp is the best and 'Pypp is the best'\")\n\nDirectives\n==========\n\nName definitions (#define, #undef)\n----------------------------------\n\nDefine names, or names with values that will be stored in definition dictionary.\n\n``#define identifier [expression]``\n\nWhen the preprocessor encounters this directive, it creates an entry in its definition dictionary with name ``identifier`` and the value with evaluation of ``expression``. If ``expression`` is ommited, ``True`` is used. \n\n.. code:: Python\n\n    #define DEBUG\n    #define TABLE_SIZE (50 * 50 if __PYTHON2__ else 100 * 100)\n\n    block = list(\" \" * TABLE_SIZE)\n\n    #ifdef DEBUG\n    print(\"Debug is ON !!!\")\n    #endif\n\nTo remove an entry from definition dictionary use \n\n``#undef identifier``\n\nConditional inclusions (#if, #else, #endif and its variations)\n-----------------------------------------------------------------\n\nThese directives allow to include or discard part of the original code, also called code blocks if a certain \ncondition is met or not.\nIt works the same manner that ``if/elif/else`` in python. The diference is that we have ``#endif`` and its\nvariations to close opened ``#if blocks`` cause we don't have identation and there are more directives \nthat gives more flexibility.\n\nHere are all the conditional inclusions directives and how they are evalueted.\n\n+---------------------------------+-----------------------------------------------------------------------------------+\n| **#ifdef** ``identifier``       | | Opens a block of code and includes its content if ``identifier`` is a name      |\n|                                 | | in definition dictionary, no matter its value.                                  |\n+---------------------------------+-----------------------------------------------------------------------------------+\n| **#ifndef** ``identifier``      | | Open a block of code and includes its content if ``identifier`` is not a name   |\n|                                 | | in definition dictionary.                                                       |\n+---------------------------------+-----------------------------------------------------------------------------------+\n| **#if** ``expression``          | | Open a block of code and includes it if ``expression`` is evaluated to ``True``.|\n+---------------------------------+-----------------------------------------------------------------------------------+\n| **#else**                       | | Closes the last opened block of code,  opens a new block of code                |\n|                                 | | and includes it if any block above and at same level was not ``True``           |\n+---------------------------------+-----------------------------------------------------------------------------------+\n| **#elif** ``expression``        | | Closes the last opened block of code,  opens a new block of code                |\n|                                 | | and includes it if  ``expression`` is evaluated to ``True`` and any block       |\n|                                 | | above and at same level was not ``True``                                        |\n+---------------------------------+-----------------------------------------------------------------------------------+\n|**#elifdef** ``identifier``      | | Closes the last opened block of code,  opens a new block of code                |\n|                                 | | and includes it if ``identifier`` is a name in definition dictionary,           |\n|                                 | | no matter its value and any block above and at same level was not ``True``.     |\n+---------------------------------+-----------------------------------------------------------------------------------+\n| **#endif**                      | | Closes the last opened block of code at same level                              |\n+---------------------------------+-----------------------------------------------------------------------------------+\n| **#endififdef** ``identifier``  | | Same as **#endif** + **#ifdef** but at the same line                            |\n+---------------------------------+-----------------------------------------------------------------------------------+\n| **#endifif** ``expression``     | | Same as **#endif** + **#if** but at the same line                               |\n+---------------------------------+-----------------------------------------------------------------------------------+\n| **#endifall**                   | | Close all opened blocks no matter if they are inner or outter. Use with care.   |\n+---------------------------------+-----------------------------------------------------------------------------------+\n\nExamples of Conditional inclusions\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. code:: Python\n\n    # compile block if DEBUG was defined before\n\n    #ifdef DEBUG\n    print(\"Debug is ON !!!\")\n    #endif\n\n    # compile block if DEBUG was not defined or was excluded from definition dictionary \n\n    #undef DEBUG\n    #ifndef DEBUG\n    print(\"Debug is ON !!!\")\n    #endif\n\n    # compile block if expression is True\n\n    # define INT_VER int(VERSION[0])\n    #if DEBUG is True and INT_VER > 2\n    print(\"Debug is ON and Python is 3+!!!\")\n    #elif INT_VER == 2\n    print(\"Python certainly is 2.x\")\n    #else\n    print(\"I'm sure Debug is ON or OFF :)\")\n    #endif\n\nExclusion blocks (#exclude and #endexclude)\n-----------------------------------------------------------------\n\nDepending of your code, sometimes you want to exclude an entire block of code if some conditions are met or not\nor not, or  maybe you wants that only the preprocessor executes this portion of code, but wants remove this \nportion from final code. For this we have the directives **#exclude** and **#endexclude**. All inside this two directives will be completely exclude from final code, but will be seen by preprocessor.\n\n.. code:: Python\n\n   #exclude\n   import numpy\n   #endexclude\n\n   #define NUMPY_E numpy.e\n   #define NUMPY_EULER_GAMA numpy.euler_gama\n   numpy_e = NUMPY_E\n   numpy_euler_gama = NUMPY_EULER_GAMA\n\nWe imported numpy package only at preprocessor time to get the values of these two constants and set two local\nvariables. ``numpy`` package won't be needed at the machine where the final code will execute. Neither Pypp as \nwe already know.\n\nIgnore blocks (#ignore and #endignore)\n-----------------------------------------------------------------\n\nThese directives do exactly what their name says. They ignore from the preprocessor an entire block of code.\n\n.. code:: Python\n\n   #ignore\n   #define NONE \"This defines will never occurs because this block is ignored\"\n   #ifndef NONE\n   print(\"This !TEXT will be printed exactly how it is #{PRINT_ME#}\") # Will print always\n   #endif\n   #endignore\n\nSource file inclusion (#include and #includeident)\n-----------------------------------------------------------------\n\nWhen the preprocessor finds an ``#include`` or ``#includeident`` directive it replaces it by the entire \ncontent of the specified file. The diference between ``#include`` and ``#includeident`` is that \n``#include`` will always include each line of included file starting of column 1 and ``#includeident`` will\nalways include each line of incuded file starting at same column where ``#includeident`` was written. \nThere are two ways to use #include:\n\n+-----------------------------+------------------------------------------------------------------------------------+\n| **#include** ``<filename>`` | | When filename is specified between angle-backets, Pypp looks for the             |\n|                             | | filename in all directories listed in ``sys.path``. The first existing file      |\n|                             | | will be included.                                                                |\n+-----------------------------+------------------------------------------------------------------------------------+\n| **#include** ``expression`` | | When filename is not specified between angle-brackes, Pypp assumes that this     |\n|                             | | is an expression, evaluates it and the result as used as  absolute path of file. |\n|                             | | If the file exists it will be included.                                          |\n+-----------------------------+------------------------------------------------------------------------------------+\n\nSupose that ``include.py`` has the following content.\n\n::\n\n    print(\"I'm an included file\")\n\nNow let's see this code.\n\n.. code:: Python\n\n   #include \"include.py\"\n       #include \"include.py\"\n\n   if some_condition:\n      #includeident \"include.py\"\n\nIf we check the preprocessed file we will find:\n\n.. code:: Python\n\n   print(\"I'm an included file\")\n   print(\"I'm an included file\")\n\n   if some_condition:\n      print(\"I'm an included file\")\n\nCode protection (#expand)\n-------------------------\n\nAs you remember, the original code is compiled twice, one before the preprocessor and other after.\nSo at both compiling steps the code must be correct and without syntax or grammar errors.\n\nSometimes we want to implement some features in our code that are not available in all Python versions,\nbut we need that our code compile correctly so the preprocessor can do its work. For this we have ``#expand``\ndirective. If you had a piece of code that is not compatible with all versions of Python you put it as parameter \nof ``#expand``. The first step of compiling will consider this line as a comment and will ignore it. And the \npreprocessor will do its job. For example:\n\n.. code:: Python\n\n  #if __PYTHON2__\n  print \"This\",\"is\", \"a\",\"python\",\"program\"\n  #else\n  print (\"This is a python program\")\n  #endif\n\nThe code above will generate a compile error if we try to run it on Python 3+, because the first ``print`` statement\ndoes not meet the Python 3 syntax. So the solution is to hide this code from first compiling. ``#expand`` will do\nthis for us.\n\n.. code:: Python\n\n  #if __PYTHON2__\n  #expand print \"This\",\"is\", \"a\",\"python\",\"program\"\n  #else\n  print (\"This is a python program\")\n  #endif\n\nNow the first compiling will occur with no problem no matter what Python version is used \nand the preprocessor will go on.\n\n\nContributing\n============\n\nPlease send an email to `wellrats@gmail.com <mailto:wellrats@gmail.com>`_\n\n\n",
        "description_content_type": "",
        "docs_url": null,
        "download_url": "",
        "downloads": {
            "last_day": -1,
            "last_month": -1,
            "last_week": -1
        },
        "home_page": "https://github.com/wellrats/python-pypp",
        "keywords": "",
        "license": "",
        "maintainer": "",
        "maintainer_email": "",
        "name": "python-pypp",
        "package_url": "https://pypi.org/project/python-pypp/",
        "platform": "",
        "project_url": "https://pypi.org/project/python-pypp/",
        "project_urls": {
            "GitHub: issues": "https://github.com/wellrats/python-pypp/issues",
            "GitHub: repo": "https://github.com/wellrats/python-pypp",
            "Homepage": "https://github.com/wellrats/python-pypp"
        },
        "release_url": "https://pypi.org/project/python-pypp/1.0.2/",
        "requires_dist": null,
        "requires_python": "",
        "summary": "Python preprocessor implementation",
        "version": "1.0.2"
    },
    "last_serial": 6398489,
    "releases": {
        "1.0.2": [
            {
                "comment_text": "",
                "digests": {
                    "md5": "906314a73c77306deab1f4117c0e43ba",
                    "sha256": "6fbc7f1bb29b1da88e783cfb31298bab6f8c1a0c85e892eacfeaa56d41c2e926"
                },
                "downloads": -1,
                "filename": "python_pypp-1.0.2-py2.py3-none-any.whl",
                "has_sig": false,
                "md5_digest": "906314a73c77306deab1f4117c0e43ba",
                "packagetype": "bdist_wheel",
                "python_version": "py2.py3",
                "requires_python": null,
                "size": 31572,
                "upload_time": "2020-01-05T15:18:25",
                "upload_time_iso_8601": "2020-01-05T15:18:25.975263Z",
                "url": "https://files.pythonhosted.org/packages/b7/32/d15b032537459ab834c12a9bc927a2f842a24cb09a5ff65321143424583a/python_pypp-1.0.2-py2.py3-none-any.whl"
            }
        ]
    },
    "urls": [
        {
            "comment_text": "",
            "digests": {
                "md5": "906314a73c77306deab1f4117c0e43ba",
                "sha256": "6fbc7f1bb29b1da88e783cfb31298bab6f8c1a0c85e892eacfeaa56d41c2e926"
            },
            "downloads": -1,
            "filename": "python_pypp-1.0.2-py2.py3-none-any.whl",
            "has_sig": false,
            "md5_digest": "906314a73c77306deab1f4117c0e43ba",
            "packagetype": "bdist_wheel",
            "python_version": "py2.py3",
            "requires_python": null,
            "size": 31572,
            "upload_time": "2020-01-05T15:18:25",
            "upload_time_iso_8601": "2020-01-05T15:18:25.975263Z",
            "url": "https://files.pythonhosted.org/packages/b7/32/d15b032537459ab834c12a9bc927a2f842a24cb09a5ff65321143424583a/python_pypp-1.0.2-py2.py3-none-any.whl"
        }
    ]
}